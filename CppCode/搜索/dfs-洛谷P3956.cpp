#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
//0红色 1黄色 ->1红色 2黄色 
const int dx[4]={0,1,0,-1};
const int dy[4]={1,0,-1,0};//四个方向 
int map[101][101],me[101][101];
int MAX=1e9;
int m,n;
void dfs(int x,int y,int sum,bool flag)
{
	//if(x<1||y<1||x>m||y>m) return;没有必要判断 
	if(sum>=me[x][y]) return ;//当当前走到此点时的花费大于另一条路线走过此点的花费时返回，即这是已经走过的点，避免重复走 
	                         //剪枝 有了这个剪枝后不需要标记数组了因为如果走重复路线花费一定大于已经走过的 
	me[x][y]=sum;
	if(x==m&&y==m) return; 
	for(int i=0;i<4;i++){
		int nx=x+dx[i],ny=y+dy[i];
		if(nx<1||ny<1||nx>m||ny>m) continue;
		if(map[nx][ny]){
			if(map[nx][ny]==map[x][y]) dfs(nx,ny,sum,true);//颜色相同不花费金币 
			else                       dfs(nx,ny,sum+1,true); //颜色不同花费1个金币 
		} 
		else if(flag){
				map[nx][ny]=map[x][y];//使用魔法花费2个金币 ，将白色变成其他颜色 
				
				dfs(nx,ny,sum+2,false);
				map[nx][ny]=0;//魔法消失，变回原来的白色 
		} 
	}
}
int main()
{
	cin>>m>>n;
	int x,y,c;
	for(int i=0;i<n;i++){
		cin>>x>>y>>c;
		map[x][y]=c+1;
	}
	for(int i=1;i<=m;i++)
		for(int j=1;j<=m;j++) me[i][j]=MAX;//表示走到(i,j)点的花费金币数 
	dfs(1,1,0,true);
	if(me[m][m]==MAX) cout<<"-1";//表示走不到 
	else  cout<<me[m][m];//输出走到(m,m)点所花费的金币数 
	return 0;
} 
/*
题目描述
有一个m×m的棋盘，棋盘上每一个格子可能是红色、黄色或没有任何颜色的。你现在要从棋盘的最左上角走到棋盘的最右下角。

任何一个时刻，你所站在的位置必须是有颜色的（不能是无色的）， 你只能向上、 下、左、 右四个方向前进。当你从一个格子走向另一个格子时，如果两个格子的颜色相同，那你不需要花费金币；如果不同，则你需要花费 11个金币。

另外， 你可以花费 22 个金币施展魔法让下一个无色格子暂时变为你指定的颜色。但这个魔法不能连续使用， 而且这个魔法的持续时间很短，也就是说，如果你使用了这个魔法，走到了这个暂时有颜色的格子上，你就不能继续使用魔法； 只有当你离开这个位置，走到一个本来就有颜色的格子上的时候，你才能继续使用这个魔法，而当你离开了这个位置（施展魔法使得变为有颜色的格子）时，这个格子恢复为无色。

现在你要从棋盘的最左上角，走到棋盘的最右下角，求花费的最少金币是多少？

输入格式
第一行包含两个正整数m, nm,n，以一个空格分开，分别代表棋盘的大小，棋盘上有颜色的格子的数量。

接下来的nn行，每行三个正整数x, y, cx,y,c， 分别表示坐标为(x,y)(x,y)的格子有颜色cc。

其中c=1c=1 代表黄色，c=0c=0 代表红色。 相邻两个数之间用一个空格隔开。 棋盘左上角的坐标为(1, 1)(1,1)，右下角的坐标为( m, m)(m,m)。

棋盘上其余的格子都是无色。保证棋盘的左上角，也就是(1, 1)(1,1) 一定是有颜色的。

输出格式
一个整数，表示花费的金币的最小值，如果无法到达，输出-1?。

输入输出样例
输入 
5 7
1 1 0
1 2 0
2 2 1
3 3 1
3 4 0
4 4 1
5 5 0
输出 
8
输入 
5 5
1 1 0
1 2 0
2 2 1
3 3 1
5 5 0
输出 #2复制
-1
*/ 
