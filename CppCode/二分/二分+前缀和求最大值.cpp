/*
AC wing--102
农夫约翰的农场由 N 块田地组成，每块地里都有一定数量的牛，其数量不会少于 1 头，也不会超过 2000 头。
约翰希望用围栏将一部分连续的田地围起来，并使得围起来的区域内每块地包含的牛的数量的平均值达到最大。
围起区域内至少需要包含 F 块地，其中 F 会在输入中给出。
在给定条件下，计算围起区域内每块地包含的牛的数量的平均值可能的最大值是多少。
输入格式
第一行输入整数 N 和 F，数据间用空格隔开。
接下来 N 行，每行输入一个整数，第 i+1 行输入的整数代表第 i 片区域内包含的牛的数目。
输出格式
输出一个整数，表示平均值的最大值乘以 1000 再 向下取整 之后得到的结果。
数据范围
1≤N≤100000
1≤F≤N
*/
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int N,F;
//平均值为浮点数-->double
double a[100010];
double s[100010];//前缀和数组
bool check(double x)//假设最大平均值为x---->末尾详解
{
    for(int i=1;i<=N;i++) s[i]=s[i-1]+(a[i]-x);//求每个元素值减去平均值之后的前缀和
    ///如果要是求得在某个区间长度大于等于F之间的元素和大于0说明当前的平均值x还不是最大，返回主函数中继续二分查找更大的
    double Min=0x3f3f3f3f;
    for(int i=0,j=F;j<=N;i++,j++){  //设置双指针i,j初始i=0,j=F;每次都同时+1这样可以保证所求区间之和的区间长度 >=F
        if(s[i]<Min) Min=s[i];//遍历[0,N-F]之间的最小值
        if(s[j]-Min>0)    //假设此时s[k]=Min,[k+1,j]区间之和等于(s[j]-s[k])>0,说明[k+1,j]区间内的平均值大于x
            return true; //向右半部分查找更大的值
    }
    return false;//如果所有区间长度大于F的区间之和都是负数，说明假设的x值偏大，即实际最大平均值小于x -->向左半部分查找更小的值
}
int main()
{
    cin>>N>>F;
    for(int i=1;i<=N;i++){
        cin>>a[i];
    }
    double l=1,r=2000;//二分范围
    while(r-l>1e-5){ //根据题目确定精度
        double mid=(l+r)/2;//浮点数不能用>>操作
        if(check(mid)) l=mid;
        else r=mid;
    }
    cout<<int(r*1000)<<endl;
    cout<<l<<" "<<r;
    return 0;
}
/*
输入样例：
10 6
6 
4
2
10
3
8
5
9
4
1
输出样例：
6500
*/
/*
check函数思路：
①：我们要找的是 有没有一段不小于F的区间，使这段区间的平均数尽可能的大，如果我们找到了一段连续的区间且区间长度不小于F且
    平均数大于我们二分的平均数 那么大于这个数且区间也满足的一定满足了 我们直接判断正确即可

②：因为我们要找一段区间的平均数，根据平均数的一个基本应用，显而易见，对于一段序列，每个数减去我们所算的平均数，
    如果大于0 那么他本身就大于平均数，如果小于0 那么它本身就小于平均数 此时我们就能算出哪些数大于0 哪些数小于0 ，之后我们再使用前缀和，就能判断一个区间内的平均值是否大于或小于我们二分的平均数了

③：据②我们还可以继续优化，因为我们不仅需要找F大小区间内，我们还要找＞F大小区间内的，我们如果用二次for太费时间了，
我们这里可以使用双指针的做法，我们设i=0,j=F每次使两个数++ 因为i,j始终满足相距F的距离，所以我们用一个变量Min来存储i所
遍历到的最小值，这样我们比较的距离一定是≥F的，并且如果我们用j位的前缀和数减去Min的话，
就能得到我们的最优解，如果这个最优解＞= 0 那么就满足我们的指定条件（如果不懂这一步 请看②）。
*/

