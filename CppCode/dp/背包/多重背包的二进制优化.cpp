#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
/*
多重背包问题通常可转化成01背包问题求解。但若将每种物品的数量拆分成多个1的话，时间复杂度会很高，从而导致TLE。
所以，需要利用二进制优化思想。即：
一个正整数n，可以被分解成1,2,4,…,2^(k-1),n-2^k+1的形式。其中，k是满足n-2^k+1>0的最大整数。


例如，假设给定价值为2，数量为10的物品，依据二进制优化思想可将10分解为1+2+4+3，则原来价值为2，数量为10的物品
可等效转化为价值分别为1*2，2*2，4*2，3*2，即价值分别为2，4，8，6，数量均为1的物品。

*/
int n,m;
int w[1010],v[1010],s[1010];//起初每件物品的重量，价值，个数
int w2[2010],v2[2010];  //分解后的每件物品的重量，价值(分解后每件物品的数量都是一个-----> 01背包求解 )
int dp[2010];           //分解之后的w2[],v2[],dp[]数组要适当扩大，因为分解之后的物品种类会增多
int cnt;//记录分解后的物品总件数
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>w[i]>>v[i]>>s[i];
        int k=1;  // k 初始值为 1
        while(s[i]/k!=0){ //while(s[i]>=k) //如果当前物品的数量比 k 值大，就分解出来 k 件物品成为一件新的物品，重量为 k*w[i],价值为 k*v[i]
            w2[++cnt] = k*w[i];//新的物品重量为 k*w[i]
            v2[cnt] = k*v[i];  //新的物品价值为 k*w[i]
            s[i] -= k;   //该物品的数量减去分解出去的 k 件物品
            k *= 2;      // k 值乘以 2 
        }
        if(s[i]!=0){   //如果最后该物品的数量小于 k 值，即无法分解出来 k 件物品，则将剩余的该物品的数量合并成一个新的物品
            w2[++cnt] = s[i]*w[i]; //新的物品重量为  s[i]*w[i]
            v2[cnt] = s[i]*v[i];   //新的物品重量为  s[i]*w[i]
        }
    }
    //for(int i=1;i<=cnt;i++) cout<<w2[i]<<" "<<v2[i]<<endl;
    n = cnt;  //分解之后物品的总件数就变成了  cnt
    for(int i=1;i<=n;i++){   //01背包求解即可
        for(int j=m;j>=0;j--){
            if(j>=w2[i]) dp[j] = max(dp[j],dp[j-w2[i]]+v2[i]);
        }
    }
    cout<<dp[m]<<endl;
    return 0;
}

/*
输入
10 100
8 7 1
2 2 5
2 2 3
8 6 250
10 7 200
5 2 400
2 1 948
1 1 1
7 4 285
1 1 3

输出
81
标准答案
81
*/