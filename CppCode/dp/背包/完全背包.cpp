#include<iostream>
#include<cstdio>
using namespace std;
int n,c;
int w[1010],v[1010],dp[1010];
int f[1010][1010];
/*
完全背包问题有一个很简单有效的优化，是这样的：若两件物品i、j满足c[i]<=c[j]且w[i]>=w[j]，则将物品j去掉，不用考虑。
这个优化的正确性显然：任何情况下都可将价值小费用高得j换成物美价廉的i，得到至少不会更差的方案。对于随机生成的数据，
个方法往往会大大减少物品的件数，从而加快速度。然而这个并不能改善最坏情况的复杂度，因为有可能特别设计的数据可以
一件物品也去不掉。
*/
int two_array()  //完全背包二维数组做法
{
    for(int i=0;i<=n;i++){
        for(int j=0;j<=c;j++) f[i][j]=0;
    }
    for(int i=1;i<=n;i++){
        for(int j=0;j<=c;j++) f[i][j] = f[i-1][j];
        for(int j=0;j<=c;j++){
            if(j>=w[i]) f[i][j] = max(f[i][j],f[i][j-w[i]]+v[i]);//01背包是由上一个物品所在行的状态求出，而完全背包是由当前物品所在行的状态求出
        }
    }
    return f[n][c];
}
int main()
{
    cin>>n>>c;
    for(int i=1;i<=n;i++){
        cin>>w[i]>>v[i];
    }
    for(int i=1;i<=n;i++){    //一维数组做法
        for(int j=0;j<=c;j++){    //与01背包空间优化后的一维数组做法正好相反
            if(j>=w[i]){
                dp[j] = max(dp[j],dp[j-w[i]]+v[i]);
            }
        }
/*
此代码与01背包的代码只有 j 的循环次序不同而已。为什么这样一改就可行呢？首先想想为什么01背包中要按照j=M..0的逆序
来循环。这是因为要保证第i次循环中的状态f[i][v]是由状态f[i-1][v-c[i]]递推而来。换句话说，这正是为了保证每件物品
只选一次，保证在考虑“选入第i件物品”这件策略时，依据的是一个绝无已经选入第i件物品的子结果f[i-1][v-c[i]]。
而现在完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第i种物品”这种策略时，却正需要
一个可能已选入第i种物品的子结果f[i][v-c[i]]，所以就可以并且必须采用v= 0..V的顺序循环
*/
        //  for(int j=w[i];j<=c;j++){   //j可以从当前物品的重量大小开始遍历，就不用判断j是否大于w[i]了
        //     dp[j] = max(dp[j],dp[j-w[i]]+v[i]);
        // }
    }
    cout<<dp[c]<<endl;
    //cout<<two_array()<<endl;
    return 0;
}
/*
4 5
1 2
2 4
3 4
4 5
---->10
*/
/*
　从二维数组上区别0-1背包和完全背包也就是状态转移方程就差别在放第i中物品时，完全背包在选择放这个物品时，最
优解是F[i][j-c[i]]+w[i]即画表格中同行的那一个，而0-1背包比较的是F[i-1][j-c[i]]+w[i]，上一行的那一个。

　　从一维数组上区别0-1背包和完全背包差别就在循环顺序上，0-1背包必须逆序，因为这样保证了不会重复选择已经选择的物品，
而完全背包是顺序，顺序会覆盖以前的状态，所以存在选择多次的情况，也符合完全背包的题意。状态转移方程都为F[i] = max(F[i],dp[F-c[i]]+v[i])。
————————————————
版权声明：本文为CSDN博主「Allen_0526」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_38984851/article/details/81133840/
*/